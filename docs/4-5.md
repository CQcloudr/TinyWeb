# **C++构建高性能Web服务器——Step 4-7：Http Proxy的实现**

## **一、想法:**

user在请求source-server的web资源时，有可能会通过代理服务器。

- 在请求资源时：代理服务器即扮演者server的角色，接收user的请求；同时扮演client的角色，将user的请求传递给source-server。
- 当source-server为user作出响应时，先将响应传递给代理服务器，然后代理服务器将响应在发送给user。



https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.32

https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control

## **二、软件设计分析：**

由于Proxyer的即扮演着server的角色，有扮演着client的角色，所以基于目前tiny-core的架构，是需要两个Protocol进行交互的。作为server时，protocol是```WebProtocol```；作为client时，protocol是```HttpProxyProtocol```（继承自ClientPoolProtocol）。

在这里，我们将HttpProxyer作为全局单例模式进行设计，加载单例```ClientPool```，作为客户端发起连接的模块，之中包括：连接的预处理，错误处理，超时重连，keep-connect的配置。

各个模块之间的关系
由HttpProxyer初始化模块ClientPool，根据具体请求选择FcgiModel，CacheModel。具体的架构设计待定。

WebProtocol中的callback```dataReceived（）```接收到数据，加载HttpParser进行Request报文的解析，加载HttpBuilder进行Response报文的构建。然后调用Protocol提供的sendChain（）进行异步报文的发送。全程实现无阻塞处理。HttpProxyer到底在什么时候加载，与HttpParser和HttpBuilder之间的关系是什么。

## 几个要准备的设计问题

### 1. Cache-File 的 mata-data如何存储，存储的位置

### 2. Cache-File 文件位置是生成的

### 3. Cache-File 文件名如何生成

### 4. Cache-File 文件数据如何存储

缓存文件的格式是类似于HTTP Response:

```
HTTP Response Line\r\n
HTTP Header\r\n
HTTP Header\r\n
\r\n
HTTP Response Body
```

在设计时，developer添加了一些TinyWeb Cache 专门使用的HTTP header

Cache文件最后一次合法的时间：

```
TinyWeb-Cache-Date
```

Cache文件源Url地址：（一定存在）

```
TinyWeb-Cache-Location
```

Cache文件中body在文件的offset：（不一定存在，但是body肯定自\r\n\r\n后开始）

```
TinyWeb-Cache-Body-Offset
```

Cache系统 最后一次读取缓存文件的时间：

```
TinyWeb-Cache-Access

```
  
## **End、参考代码文献**

[基于C++的开源日志系统](https://github.com/fffaraz/awesome-cpp#logging)




本文主要介绍当完成http语法解析之后，我们成功分析出各种字段（mouthed，http-version，headers。
可是要进一步分成http解析，还需要语义分析。
举一个简单的例子：HTTP/1.0 在对connection的默认处理时close，除非在header设置 Connection：keep-alive；HTTP/1.1 默认处理为keep-alive，除非设置close。

另一个例子就是：header信息之间存在冲突，比如chunked和content-length，如果存在多个相同的头部字段
到底该选择那个行为。
所以服务器的行为要通过分析多个值，来作出综合判断。


## 总结如下，在语义分析中应该处理那些细节：

### 在处理request-body：

- GET 也可以发送body
- content-length和chunked同时存在，错误
- 对于非持久化连接，可以通过connection的断开来判定body发送已经结束。
- 持久化连接，必须通过Content-Length或Transfer-Encoding来判定body发送已经结束。
- 响应为1xx，204，304相应或者head请求，则直接忽视掉消息实体内容。
- 如果有Transfer-Encoding，则优先采用Transfer-Encoding里面的方法来找到对应的长度。比如说Chunked模式。
- 有了Transfer-Encoding，则不能有Content-Length。
- Range传输。
- 通过服务器关闭连接能确定消息的传输长度。（请求端不能通过关闭连接来指明请求消息体的结束，因为这样可以让服务器没有机会继续给予响应）。这种情况主要对应为短连接，即非keep-alive模式。
- HTTP1.1必须支持chunk模式。因为当不确定消息长度的时候，可以通过chunk机制来处理这种情况。
- 在包含消息内容的header中，如果有content-length字段，那么该字段对应的值必须完全和消息主题里面的长度匹配。
- 静态页面使用Content-Length
- 动态页面使用Chunked
- A client MUST send a Host header field in all HTTP/1.1 request
   messages.



# update plan 

## [accept](https://tools.ietf.org/html/rfc7231#section-5.3.2)
```
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b2
```

```
Accept: text/*, text/plain, text/plain;format=flowed, */*
```

```
Accept: text/*, text/html, text/html;level=1, */*
```

test pattern
```









text/html, text/*
text/html, application/xhtml+xml, text/*
text/html, application/xhtml+xml,application/xml, text/*
text/html, application/xhtml+xml, application/xml, image/webp, text/*

text/html, */*
text/html, application/xhtml+xml, */*
text/html, application/xhtml+xml, application/xml, */*
text/html, application/xhtml+xml, application/xml, image/webp,*/*

application/xml;q=0.9
application/xml;q=0.8
application/xml;q=0.9,text/html

application/signed-exchange;v=b2,

application/xml;q=0.9,application/signed-exchange;v=b2
application/xml;q=0.9;v=b3,application/signed-exchange;v=b2

text/plain;format=flowed, */*

text/html;level=1, */*,application/xml;q=0.8

```
mimetype:
0-9
a-z
A-Z
/*.-_

factor
a-z
A-Z
0-9
.


text/html, application/xhtml+xml, application/xml, image/webp,*/*,text/html;level=1, */*,application/xml;q=0.8,
q参数
```
 The weight is normalized to a real number in the range 0 through 1,
   where 0.001 is the least preferred and 1 is the most preferred; a
   value of 0 means "not acceptable".  If no "q" parameter is present,
   the default weight is 1.
```



```
test/html
test/*
*/*

```


## headers
- accept-ranges: bytes
- date: Fri, 11 Jan 2019 07:20:15 GMT
- expires: Fri, 11 Jan 2019 07:20:15 GMT
- last-modified: Wed, 14 Dec 2016 20:30:00 GMT
- cache-control: private, max-age=31536000
- cache-control: no-cache
- cache-control: max-age=0
- accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b2
- accept-encoding: gzip, deflate, br
- accept-language: zh-CN,zh;q=0.9,en;q=0.8,ja;q=0.7
- Cookie: _ga=GA1.2.853646746.1544367008; _gid=GA1.2.1575374377.1547191546
- Host: www.dissigil.cn
- Pragma: no-cache
- Upgrade-Insecure-Requests: 1
- User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36


 transfer-coding    = "chunked" ; Section 4.1
                        / "compress" ; Section 4.2.1
                        / "deflate" ; Section 4.2.2
                        / "gzip" ; Section 4.2.3




## post method
- Content-Type: multipart/form-data; boundary=你的自定义boundary
